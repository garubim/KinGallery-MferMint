{
  "language": "Solidity",
  "sources": {
    "KinGallery.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n\ninterface IERC20Permit {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n    function nonces(address owner) external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        _status = _NOT_ENTERED;\n    }\n\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n\ninterface IAccessControl {\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nlibrary Math {\n    enum Rounding { Down, Up, Zero }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0;\n            uint256 prod1;\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            prod0 |= prod1 * twos;\n\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 result = 1 << (log2(a) >> 1);\n\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n\nlibrary SignedMath {\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n        _revokeRole(role, account);\n    }\n\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\npragma solidity ^0.8.19;\n\ninterface IMferMint {\n    function mintFor(address to, string calldata paymentId) external;\n    function mintForWithEthFromGallery(address to, string calldata paymentId) external payable;\n}\n\ncontract KinGallery is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20Metadata;\n\n    bytes32 public constant ADMIN_ROLE = DEFAULT_ADMIN_ROLE;\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    address private constant ADDRESS_ZERO = address(0);\n\n    IERC20Metadata public immutable usdc;\n    address public feeRecipient;\n    uint256 public feeBps;\n\n    address public payee1;\n    address public payee2;\n    uint256 public constant PAYEE1_AMOUNT = 200_000_000_000_000;\n    uint256 public constant PAYEE2_AMOUNT = 100_000_000_000_000;\n\n    mapping(string => bool) public processedPayment;\n\n    event FeeUpdated(address indexed recipient, uint256 bps);\n    event Processed(address indexed artistContract, address indexed to, uint256 amount, string paymentId);\n    event WithdrawnUSDC(address indexed to, uint256 amount);\n    event WithdrawnETH(address indexed to, uint256 amount);\n    event RoleGranted(bytes32 indexed role, address indexed account);\n    event RoleRevoked(bytes32 indexed role, address indexed account);\n    event PayeeUpdated(address indexed payee1, address indexed payee2);\n    event ETHReceived(address indexed sender, uint256 amount);\n\n    uint256 public constant MINT_PRICE = 300_000_000_000_000;\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Only relayer\");\n        _;\n    }\n\n    modifier onlyNonRenouncingAdmin() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Only admin\");\n        _;\n    }\n\n    constructor(\n        address _usdc,\n        address _multisig,\n        address _payee1,\n        address _payee2\n    ) {\n        usdc = IERC20Metadata(_usdc);\n        require(_usdc != ADDRESS_ZERO, \"USDC address required\");\n        require(usdc.decimals() == 6, \"USDC must have 6 decimals\");\n\n        feeRecipient = _multisig;\n        require(_multisig != ADDRESS_ZERO, \"Invalid multisig\");\n\n        feeBps = 0;\n        payee1 = _payee1;\n        payee2 = _payee2;\n        require(_payee1 != ADDRESS_ZERO && _payee2 != ADDRESS_ZERO, \"Payees required\");\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _multisig);\n        _grantRole(RELAYER_ROLE, _multisig);\n        emit PayeeUpdated(payee1, payee2);\n    }\n\n    function setFee(address _recipient, uint256 _bps) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_bps <= 10000, \"bps too large\");\n        require(_recipient != ADDRESS_ZERO || _bps == 0, \"invalid fee recipient\");\n        feeRecipient = _recipient;\n        feeBps = _bps;\n        emit FeeUpdated(_recipient, _bps);\n    }\n\n    function setPayees(address _payee1, address _payee2) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_payee1 != ADDRESS_ZERO && _payee2 != ADDRESS_ZERO, \"invalid payee\");\n        payee1 = _payee1;\n        payee2 = _payee2;\n        emit PayeeUpdated(_payee1, _payee2);\n    }\n\n    function setRelayer(address _relayer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_relayer != ADDRESS_ZERO, \"zero relayer\");\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RoleGranted(RELAYER_ROLE, _relayer);\n    }\n\n    function removeRelayer(address _relayer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RoleRevoked(RELAYER_ROLE, _relayer);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function processPayment(\n        address artistContract,\n        address to,\n        uint256 amount,\n        string calldata paymentId\n    ) external onlyRelayer nonReentrant {\n        require(!processedPayment[paymentId], \"Payment already processed\");\n        \n        uint256 contractBalance = usdc.balanceOf(address(this));\n        require(contractBalance >= amount, \"Insufficient USDC\");\n        \n        require(to != ADDRESS_ZERO, \"invalid recipient\");\n        require(artistContract != ADDRESS_ZERO, \"invalid artist contract\");\n\n        processedPayment[paymentId] = true;\n\n        uint256 fee = (feeBps > 0 && feeRecipient != ADDRESS_ZERO)\n            ? (amount * feeBps) / 10000\n            : 0;\n\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n        }\n\n        uint256 amountAfterFee = amount - fee;\n        usdc.safeTransfer(artistContract, amountAfterFee);\n\n        IMferMint(artistContract).mintFor(to, paymentId);\n        emit Processed(artistContract, to, amount, paymentId);\n    }\n\n    function payAndMint(\n        address artistContract,\n        address to,\n        string calldata paymentId\n    ) external payable nonReentrant {\n        require(msg.value == MINT_PRICE, \"Incorrect payment amount\");\n        require(!processedPayment[paymentId], \"Payment already processed\");\n        require(to != ADDRESS_ZERO, \"invalid recipient\");\n        require(artistContract != ADDRESS_ZERO, \"invalid artist contract\");\n        require(payee1 != ADDRESS_ZERO && payee2 != ADDRESS_ZERO, \"payees not set\");\n\n        processedPayment[paymentId] = true;\n\n        if (PAYEE1_AMOUNT > 0) payable(payee1).transfer(PAYEE1_AMOUNT);\n        if (PAYEE2_AMOUNT > 0) payable(payee2).transfer(PAYEE2_AMOUNT);\n\n        uint256 remainingValue = MINT_PRICE - PAYEE1_AMOUNT - PAYEE2_AMOUNT;\n        IMferMint(artistContract).mintForWithEthFromGallery{value: remainingValue}(to, paymentId);\n        emit Processed(artistContract, to, MINT_PRICE, paymentId);\n    }\n\n    function withdrawUSDC(uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(amount > 0, \"amount must be > 0\");\n        require(usdc.balanceOf(address(this)) >= amount, \"Insufficient USDC\");\n        usdc.safeTransfer(msg.sender, amount);\n        emit WithdrawnUSDC(msg.sender, amount);\n    }\n\n    function withdrawETH(uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(amount > 0, \"amount must be > 0\");\n        require(address(this).balance >= amount, \"Insufficient ETH\");\n        payable(msg.sender).transfer(amount);\n        emit WithdrawnETH(msg.sender, amount);\n    }\n\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": ["abi", "evm.bytecode"]
      }
    }
  }
}
