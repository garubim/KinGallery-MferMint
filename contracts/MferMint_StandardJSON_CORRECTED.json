{
  "language": "Solidity",
  "sources": {
    "contracts/MferMintGalleryCompatible_Flattened.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// OpenZeppelin Contracts (last updated v4.9.0)\n\n/**\n * @dev Interface of the ERC165 standard\n */\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n */\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165) returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    function toHexString(address value) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(value)), _ADDRESS_LENGTH);\n    }\n}\n\n/**\n * @dev Math operations with safety checks.\n */\nlibrary Math {\n    enum Rounding {\n        Down,\n        Up,\n        Zero\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 == 0) {\n            return prod0 / denominator;\n        }\n\n        require(denominator > prod1, \"Math: mulDiv overflow\");\n\n        uint256 remainder;\n        assembly {\n            remainder := mod(prod0, denominator)\n            prod0 := div(prod0, denominator)\n            prod1 := div(prod1, denominator)\n            let delta := sub(denominator, remainder)\n            prod1 := sub(prod1, gt(delta, prod0))\n            prod0 := sub(prod0, delta)\n        }\n\n        return prod0;\n    }\n\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 result = 1 << (log2(a) >> 1);\n\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 1;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 1;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 1;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 1;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 1;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 1;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 1;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n}\n\n/**\n * @dev Provides information about the current execution context.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Interface of ERC721\n */\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n\n/**\n * @dev ERC721 implementation\n */\ncontract ERC721 is Context, ERC165, IERC721 {\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not token owner or approved for all\");\n        _approve(to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _approve(address(0), tokenId);\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n}\n\n/**\n * @dev Interface for ERC2981 royalties\n */\ninterface IERC2981 is IERC165 {\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount);\n}\n\n/**\n * @dev ERC2981 implementation\n */\nabstract contract ERC2981 is IERC2981, ERC165 {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n\n    RoyaltyInfo private _defaultRoyaltyInfo;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\n        RoyaltyInfo memory royalty = _defaultRoyaltyInfo;\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / 10000;\n        return (royalty.receiver, royaltyAmount);\n    }\n\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        require(feeNumerator <= 10000, \"ERC2981: royalty fee will exceed salePrice\");\n        require(receiver != address(0), \"ERC2981: invalid receiver\");\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    function _deleteDefaultRoyalty() internal virtual {\n        delete _defaultRoyaltyInfo;\n    }\n}\n\n/**\n * @title MferMintGalleryCompatible\n * @notice Smart gallery-compatible NFT contract with creator-friendly pricing model:\n * \n * MINTING FLOWS:\n * 1. creatorMint() → Artist mints FREE (no ETH, only gas)\n * 2. mintForWithEthFromGallery() + to==artist → Artist's ETH is refunded (generous model)\n * 3. mintForWithEthFromGallery() + to≠artist → Gallery receives ETH commission (normal flow)\n * \n * This matches the Zora/Highlight/Transient Labs approach: \n * Creators get generous terms, galleries only profit from third-party mints.\n */\ncontract MferMintGalleryCompatible is ERC721, ERC2981, Ownable {\n    uint256 private _tokenIdCounter = 1;\n    string private _baseTokenURI = \"ipfs://metadata/\";\n    address public gallery;\n    address public artist;\n    uint96 public royaltyPercentage;\n    \n    mapping(bytes32 => bool) public mintedWithPaymentId;\n    \n    event MintedFor(address indexed to, uint256 indexed tokenId, bytes32 paymentId);\n    event ArtistMinted(address indexed artist, uint256 tokenId, bytes32 paymentId);\n    event RoyaltyUpdated(uint96 percentage);\n    \n    constructor(\n        string memory name_,\n        string memory symbol_,\n        string memory baseURI_,\n        address initialOwner_\n    ) ERC721(name_, symbol_) Ownable() {\n        require(initialOwner_ != address(0), \"Invalid owner\");\n        if (bytes(baseURI_).length > 0) {\n            require(bytes(baseURI_)[bytes(baseURI_).length - 1] == '/', \"BaseURI must end with /\");\n            _baseTokenURI = baseURI_;\n        }\n        gallery = initialOwner_;\n        artist = initialOwner_;\n        royaltyPercentage = 500; // 5% default\n        \n        // Set default royalty: 5% to artist\n        _setDefaultRoyalty(initialOwner_, 500);\n    }\n    \n    modifier onlyGallery() {\n        require(msg.sender == gallery, \"Only gallery\");\n        _;\n    }\n    \n    modifier onlyArtist() {\n        require(msg.sender == artist, \"Only artist\");\n        _;\n    }\n    \n    function mintFor(address to, bytes32 paymentId) external onlyGallery {\n        require(to != address(0), \"Invalid to\");\n        require(paymentId != bytes32(0), \"Invalid paymentId\");\n        require(!mintedWithPaymentId[paymentId], \"Used\");\n        \n        mintedWithPaymentId[paymentId] = true;\n        uint256 tokenId = _tokenIdCounter++;\n        _safeMint(to, tokenId);\n        \n        emit MintedFor(to, tokenId, paymentId);\n    }\n    \n    function mintForWithEthFromGallery(address to, bytes32 paymentId) external payable onlyGallery {\n        require(to != address(0), \"Invalid to\");\n        require(paymentId != bytes32(0), \"Invalid paymentId\");\n        require(!mintedWithPaymentId[paymentId], \"Used\");\n        \n        mintedWithPaymentId[paymentId] = true;\n        uint256 tokenId = _tokenIdCounter++;\n        _safeMint(to, tokenId);\n        \n        uint256 ethToTransfer = msg.value;\n        \n        // If artist is minting their own work via gallery, refund the fee\n        // This keeps the creator's ETH in their wallet\n        if (to == artist && msg.value > 0) {\n            (bool success, ) = payable(to).call{value: msg.value}(\"\");\n            require(success, \"Refund failed\");\n            ethToTransfer = 0;\n        } else if (msg.value > 0) {\n            // Normal flow: gallery gets the commission\n            (bool success, ) = payable(owner()).call{value: msg.value}(\"\");\n            require(success, \"Transfer failed\");\n        }\n        \n        emit MintedFor(to, tokenId, paymentId);\n    }\n    \n    function creatorMint() external onlyArtist returns (uint256) {\n        uint256 tokenId = _tokenIdCounter++;\n        _safeMint(artist, tokenId);\n        \n        emit ArtistMinted(artist, tokenId, bytes32(0));\n        return tokenId;\n    }\n    \n    function setRoyalty(uint96 newPercentage) external onlyOwner {\n        require(newPercentage <= 10000, \"Max 100%\");\n        royaltyPercentage = newPercentage;\n        _setDefaultRoyalty(artist, newPercentage);\n        \n        emit RoyaltyUpdated(newPercentage);\n    }\n    \n    function setArtist(address newArtist) external onlyOwner {\n        require(newArtist != address(0), \"Invalid artist\");\n        artist = newArtist;\n        _setDefaultRoyalty(newArtist, royaltyPercentage);\n    }\n    \n    function _baseURI() internal view override returns (string memory) {\n        return _baseTokenURI;\n    }\n    \n    function setBaseURI(string memory newURI) external onlyOwner {\n        _baseTokenURI = newURI;\n    }\n    \n    function setGallery(address newGallery) external onlyOwner {\n        require(newGallery != address(0), \"Invalid gallery\");\n        gallery = newGallery;\n    }\n    \n    function withdrawETH() external onlyOwner {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool success, ) = payable(owner()).call{value: balance}(\"\");\n            require(success, \"Withdrawal failed\");\n        }\n    }\n    \n    function withdrawTo(address recipient) external onlyOwner {\n        require(recipient != address(0), \"Invalid recipient\");\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool success, ) = payable(recipient).call{value: balance}(\"\");\n            require(success, \"Withdrawal failed\");\n        }\n    }\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC2981) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n    \n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "metadata": {
      "useLiteralContent": true,
      "bytecodeHash": "ipfs"
    }
  }
}