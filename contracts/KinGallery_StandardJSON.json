{
  "language": "Solidity",
  "sources": {
    "contracts/KinGallery.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/IERC20.sol\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\npragma solidity ^0.8.0;\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/extensions/IERC20Metadata.sol\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\npragma solidity ^0.8.0;\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/extensions/IERC20Permit.sol\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\npragma solidity ^0.8.0;\ninterface IERC20Permit {\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function nonces(address owner) external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/utils/Context.sol\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\npragma solidity ^0.8.0;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/utils/Address.sol\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\npragma solidity ^0.8.1;\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n    function verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/utils/SafeERC20.sol\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\npragma solidity ^0.8.0;\nlibrary SafeERC20 {\n    using Address for address;\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/security/ReentrancyGuard.sol\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\npragma solidity ^0.8.0;\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/security/Pausable.sol\n// OpenZeppelin Contracts (last updated v4.9.0) (security/Pausable.sol)\npragma solidity ^0.8.0;\nabstract contract Pausable is Context {\n    event Paused(address indexed account);\n    event Unpaused(address indexed account);\n    bool private _paused;\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/access/IAccessControl.sol\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\npragma solidity ^0.8.0;\ninterface IAccessControl {\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/utils/introspection/IERC165.sol\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\npragma solidity ^0.8.0;\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/utils/introspection/ERC165.sol\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\npragma solidity ^0.8.0;\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/access/AccessControl.sol\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\npragma solidity ^0.8.0;\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(string(abi.encodePacked(\"AccessControl: account \", account, \" is missing role \", role)));\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n        _revokeRole(role, account);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n// File: KinGallery.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IMferMint {\n    function mintFor(address to, string calldata paymentId) external;\n    function mintForWithEthFromGallery(address to, string calldata paymentId) external payable;\n    function owner() external view returns (address);\n}\n\ncontract KinGallery is AccessControl, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20Metadata;\n\n    bytes32 public constant ADMIN_ROLE = DEFAULT_ADMIN_ROLE;\n    address private constant ADDRESS_ZERO = address(0);\n\n    IERC20Metadata public immutable usdc;\n    address public feeRecipient;\n    uint256 public feeBps;\n\n    address public payee2;\n    uint256 public constant PAYEE1_AMOUNT = 200_000_000_000_000;\n    uint256 public constant PAYEE2_AMOUNT = 100_000_000_000_000;\n\n    mapping(string => bool) public processedPayment;\n\n    event FeeUpdated(address indexed recipient, uint256 indexed oldBps, uint256 indexed newBps);\n    event Processed(address indexed artistContract, address indexed artistPayee, address indexed to, uint256 amount, string paymentId);\n    event WithdrawnUSDC(address indexed to, uint256 amount);\n    event WithdrawnETH(address indexed to, uint256 amount);\n    event RoleGranted(bytes32 indexed role, address indexed account);\n    event RoleRevoked(bytes32 indexed role, address indexed account);\n    event GalleryPayeeUpdated(address indexed newPayee2);\n    event ETHReceived(address indexed sender, uint256 amount);\n    event MintPriceUpdated(uint256 indexed newPrice);\n\n    uint256 public mintPrice = 300_000_000_000_000;\n\n    modifier onlyNonRenouncingAdmin() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Only admin\");\n        _;\n    }\n\n    constructor(\n        address _usdc,\n        address _multisig,\n        address _payee2\n    ) {\n        usdc = IERC20Metadata(_usdc);\n        require(_usdc != ADDRESS_ZERO, \"USDC address required\");\n\n        feeRecipient = _multisig;\n        require(_multisig != ADDRESS_ZERO, \"Invalid multisig\");\n\n        feeBps = 0;\n        payee2 = _payee2;\n        require(_payee2 != ADDRESS_ZERO, \"Gallery payee required\");\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(DEFAULT_ADMIN_ROLE, _multisig);\n        _grantRole(DEFAULT_ADMIN_ROLE, _payee2);\n    }\n\n    function setFee(address _recipient, uint256 _bps) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_bps <= 10000, \"bps too large\");\n        require(_recipient != ADDRESS_ZERO || _bps == 0, \"invalid fee recipient\");\n        uint256 oldBps = feeBps;\n        feeRecipient = _recipient;\n        feeBps = _bps;\n        emit FeeUpdated(_recipient, oldBps, _bps);\n    }\n\n    function setGalleryPayee(address _payee2) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_payee2 != ADDRESS_ZERO, \"invalid payee\");\n        payee2 = _payee2;\n        emit GalleryPayeeUpdated(_payee2);\n    }\n\n    function setMintPrice(uint256 _price) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_price > 0, \"Price must be > 0\");\n        mintPrice = _price;\n        emit MintPriceUpdated(_price);\n    }\n\n    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function processPayment(\n        address artistContract,\n        address to,\n        uint256 amount,\n        string calldata paymentId\n    ) external nonReentrant whenNotPaused {\n        require(!processedPayment[paymentId], \"Payment already processed\");\n        \n        uint256 contractBalance = usdc.balanceOf(address(this));\n        require(contractBalance >= amount, \"Insufficient USDC\");\n        \n        require(to != ADDRESS_ZERO, \"invalid recipient\");\n        require(artistContract != ADDRESS_ZERO, \"invalid artist contract\");\n\n        processedPayment[paymentId] = true;\n\n        address artistPayee;\n        try IMferMint(artistContract).owner() returns (address _owner) {\n            require(_owner != ADDRESS_ZERO, \"Artist owner not configured\");\n            artistPayee = _owner;\n        } catch {\n            revert(\"Artist contract must implement owner() function\");\n        }\n\n        uint256 fee = (feeBps > 0 && feeRecipient != ADDRESS_ZERO)\n            ? (amount * feeBps) / 10000\n            : 0;\n\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n        }\n\n        uint256 amountAfterFee = amount - fee;\n        usdc.safeTransfer(artistPayee, amountAfterFee);\n\n        try IMferMint(artistContract).mintFor(to, paymentId) {\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"Minting failed: \", reason)));\n        } catch {\n            revert(\"Minting failed: unknown error\");\n        }\n        \n        emit Processed(artistContract, artistPayee, to, amount, paymentId);\n    }\n\n    function payAndMint(\n        address artistContract,\n        address to,\n        string calldata paymentId\n    ) external payable nonReentrant whenNotPaused {\n        require(msg.value == mintPrice, \"Incorrect payment amount\");\n        require(!processedPayment[paymentId], \"Payment already processed\");\n        require(to != ADDRESS_ZERO, \"invalid recipient\");\n        require(artistContract != ADDRESS_ZERO, \"invalid artist contract\");\n        require(payee2 != ADDRESS_ZERO, \"Gallery payee not set\");\n\n        processedPayment[paymentId] = true;\n\n        address artistPayee;\n        try IMferMint(artistContract).owner() returns (address _owner) {\n            require(_owner != ADDRESS_ZERO, \"Artist owner not configured\");\n            artistPayee = _owner;\n        } catch {\n            revert(\"Artist contract must implement owner() function\");\n        }\n\n        if (PAYEE1_AMOUNT > 0) {\n            (bool success1, ) = payable(artistPayee).call{value: PAYEE1_AMOUNT}(\"\");\n            require(success1, \"Artist transfer failed\");\n        }\n        if (PAYEE2_AMOUNT > 0) {\n            (bool success2, ) = payable(payee2).call{value: PAYEE2_AMOUNT}(\"\");\n            require(success2, \"Gallery transfer failed\");\n        }\n\n        uint256 remainingValue = mintPrice - PAYEE1_AMOUNT - PAYEE2_AMOUNT;\n        try IMferMint(artistContract).mintForWithEthFromGallery{value: remainingValue}(to, paymentId) {\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"Minting failed: \", reason)));\n        } catch {\n            revert(\"Minting failed: unknown error\");\n        }\n        \n        emit Processed(artistContract, artistPayee, to, mintPrice, paymentId);\n    }\n\n    function withdrawUSDC(uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n        require(amount > 0, \"amount must be > 0\");\n        require(usdc.balanceOf(address(this)) >= amount, \"Insufficient USDC\");\n        usdc.safeTransfer(msg.sender, amount);\n        emit WithdrawnUSDC(msg.sender, amount);\n    }\n\n    function withdrawETH(uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n        require(amount > 0, \"amount must be > 0\");\n        require(address(this).balance >= amount, \"Insufficient ETH\");\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"ETH transfer failed\");\n        emit WithdrawnETH(msg.sender, amount);\n    }\n\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n}\n"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/IERC20.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/token/ERC20/IERC20.sol"
      ]
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/token/ERC20/extensions/IERC20Metadata.sol"
      ]
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/token/ERC20/extensions/IERC20Permit.sol"
      ]
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/utils/Context.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/utils/Context.sol"
      ]
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/utils/Address.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/utils/Address.sol"
      ]
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/utils/SafeERC20.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/token/ERC20/utils/SafeERC20.sol"
      ]
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/security/ReentrancyGuard.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/security/ReentrancyGuard.sol"
      ]
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/security/Pausable.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/security/Pausable.sol"
      ]
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/access/IAccessControl.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/access/IAccessControl.sol"
      ]
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/utils/introspection/IERC165.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/utils/introspection/IERC165.sol"
      ]
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/utils/introspection/ERC165.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/utils/introspection/ERC165.sol"
      ]
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/access/AccessControl.sol": {
      "urls": [
        "https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.9.0/contracts/access/AccessControl.sol"
      ]
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata"
        ]
      }
    },
    "evmVersion": "paris"
  }
}
