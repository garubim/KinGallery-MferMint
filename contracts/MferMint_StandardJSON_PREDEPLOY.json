{
  "language": "Solidity",
  "settings": {
    "optimizer": { "enabled": true, "runs": 200 },
    "evmVersion": "paris",
    "metadata": { "bytecodeHash": "ipfs" }
  },
  "sources": {
    "contracts/MferMintGalleryCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC721/ERC721.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/common/ERC2981.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/access/Ownable.sol\";\n\n/**\n * @title MferMintGalleryCompatible\n * @notice Smart gallery-compatible NFT contract with creator-friendly pricing model:\n * \n * MINTING FLOWS:\n * 1. creatorMint() → Artist mints FREE (no ETH, only gas)\n * 2. mintForWithEthFromGallery() + to==artist → Artist's ETH is refunded (generous model)\n * 3. mintForWithEthFromGallery() + to≠artist → Gallery receives ETH commission (normal flow)\n * \n * This matches the Zora/Highlight/Transient Labs approach: \n * Creators get generous terms, galleries only profit from third-party mints.\n */\ncontract MferMintGalleryCompatible is ERC721, ERC2981, Ownable {\n    uint256 private _tokenIdCounter = 1;\n    string private _baseTokenURI = \"ipfs://metadata/\";\n    address public gallery;\n    address public artist;\n    uint96 public royaltyPercentage;\n    \n    mapping(bytes32 => bool) public mintedWithPaymentId;\n    \n    event MintedFor(address indexed to, uint256 indexed tokenId, bytes32 paymentId);\n    event ArtistMinted(address indexed artist, uint256 tokenId, bytes32 paymentId);\n    event RoyaltyUpdated(uint96 percentage);\n    \n    constructor(\n        string memory name_,\n        string memory symbol_,\n        string memory baseURI_,\n        address initialOwner_\n    ) ERC721(name_, symbol_) Ownable() {\n        require(initialOwner_ != address(0), \"Invalid owner\");\n        if (bytes(baseURI_).length > 0) {\n            require(bytes(baseURI_)[bytes(baseURI_).length - 1] == '/', \"BaseURI must end with /\");\n            _baseTokenURI = baseURI_;\n        }\n        gallery = initialOwner_;\n        artist = initialOwner_;\n        royaltyPercentage = 500; // 5% default\n        \n        // Set default royalty: 5% to artist\n        _setDefaultRoyalty(initialOwner_, 500);\n    }\n    \n    modifier onlyGallery() {\n        require(msg.sender == gallery, \"Only gallery\");\n        _;\n    }\n    \n    modifier onlyArtist() {\n        require(msg.sender == artist, \"Only artist\");\n        _;\n    }\n    \n    function mintFor(address to, bytes32 paymentId) external onlyGallery {\n        require(to != address(0), \"Invalid to\");\n        require(paymentId != bytes32(0), \"Invalid paymentId\");\n        require(!mintedWithPaymentId[paymentId], \"Used\");\n        \n        mintedWithPaymentId[paymentId] = true;\n        uint256 tokenId = _tokenIdCounter++;\n        _safeMint(to, tokenId);\n        \n        emit MintedFor(to, tokenId, paymentId);\n    }\n    \n    function mintForWithEthFromGallery(address to, bytes32 paymentId) external payable onlyGallery {\n        require(to != address(0), \"Invalid to\");\n        require(paymentId != bytes32(0), \"Invalid paymentId\");\n        require(!mintedWithPaymentId[paymentId], \"Used\");\n        \n        mintedWithPaymentId[paymentId] = true;\n        uint256 tokenId = _tokenIdCounter++;\n        _safeMint(to, tokenId);\n        \n        uint256 ethToTransfer = msg.value;\n        \n        // If artist is minting their own work via gallery, refund the fee\n        // This keeps the creator's ETH in their wallet\n        if (to == artist && msg.value > 0) {\n            (bool success, ) = payable(to).call{value: msg.value}(\"\");\n            require(success, \"Refund failed\");\n            ethToTransfer = 0;\n        } else if (msg.value > 0) {\n            // Normal flow: gallery gets the commission\n            (bool success, ) = payable(owner()).call{value: msg.value}(\"\");\n            require(success, \"Transfer failed\");\n        }\n        \n        emit MintedFor(to, tokenId, paymentId);\n    }\n    \n    function creatorMint() external onlyArtist returns (uint256) {\n        uint256 tokenId = _tokenIdCounter++;\n        _safeMint(artist, tokenId);\n        \n        emit ArtistMinted(artist, tokenId, bytes32(0));\n        return tokenId;\n    }\n    \n    function setRoyalty(uint96 newPercentage) external onlyOwner {\n        require(newPercentage <= 10000, \"Max 100%\");\n        royaltyPercentage = newPercentage;\n        _setDefaultRoyalty(artist, newPercentage);\n        \n        emit RoyaltyUpdated(newPercentage);\n    }\n    \n    function setArtist(address newArtist) external onlyOwner {\n        require(newArtist != address(0), \"Invalid artist\");\n        artist = newArtist;\n        _setDefaultRoyalty(newArtist, royaltyPercentage);\n    }\n    \n    function _baseURI() internal view override returns (string memory) {\n        return _baseTokenURI;\n    }\n    \n    function setBaseURI(string memory newURI) external onlyOwner {\n        _baseTokenURI = newURI;\n    }\n    \n    function setGallery(address newGallery) external onlyOwner {\n        require(newGallery != address(0), \"Invalid gallery\");\n        gallery = newGallery;\n    }\n    \n    function withdrawETH() external onlyOwner {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool success, ) = payable(owner()).call{value: balance}(\"\");\n            require(success, \"Withdrawal failed\");\n        }\n    }\n    \n    function withdrawTo(address recipient) external onlyOwner {\n        require(recipient != address(0), \"Invalid recipient\");\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool success, ) = payable(recipient).call{value: balance}(\"\");\n            require(success, \"Withdrawal failed\");\n        }\n    }\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC2981) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n    \n    receive() external payable {}\n}\n"
    }
  },
  "outputSelection": {
    "*": {
      "*": ["abi", "evm.bytecode.object", "evm.deployedBytecode.object", "metadata"]
    }
  }
}
